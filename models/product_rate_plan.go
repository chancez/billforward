package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit"
	"github.com/go-swagger/go-swagger/httpkit/validate"
	"github.com/go-swagger/go-swagger/strfmt"
	"github.com/go-swagger/go-swagger/swag"
)

/*ProductRatePlan A rate plan describes a pricing system under which a subscription can be made to a product.

swagger:model ProductRatePlan
*/
type ProductRatePlan struct {

	/* {"default":"(empty list)","description":"List of AggregatingComponents &mdash; these describe pricing components whose prices should be recalculated upon invoice aggregation. For example: two subscriptions' individual consumptions may be neither of them large enough to achieve bulk-buy discounts. When aggregated, though, the same two subscriptions' consumption may add up to a quantity which does merit a bulk buy discount within your tiering system.","verbs":["POST"]}
	 */
	AggregatingComponents []*AggregatingComponent `json:"aggregatingComponents,omitempty"`

	/* BillingEntity billing entity
	 */
	BillingEntity *string `json:"billingEntity,omitempty"`

	/* { "description" : "ID of the user who last updated the entity.", "verbs":[] }
	 */
	ChangedBy *string `json:"changedBy,omitempty"`

	/* {"default":"true","description":"Whether invoices are created if they have a zero valued cost before any discounts are applied.","verbs":["POST","PUT","GET"] }

	Required: true
	*/
	CreateZeroValuedInvoices bool `json:"createZeroValuedInvoices,omitempty"`

	/* { "description" : "The UTC DateTime when the object was created.", "verbs":[] }
	 */
	Created strfmt.DateTime `json:"created,omitempty"`

	/* Crmid crmid
	 */
	Crmid *string `json:"crmid,omitempty"`

	/* {"description":"The currency of the product-rate-plan &mdash; as specified by a three-character ISO 4217 currency code (i.e. USD).","verbs":["POST","GET"]}

	Required: true
	*/
	Currency string `json:"currency,omitempty"`

	/* DisplayName display name
	 */
	DisplayName *string `json:"displayName,omitempty"`

	/* {"description":"Number of length-measures which constitute the rate plan's period. If left unspecified: the rate plan will use the same `duration` number as the Product to which it belongs.","verbs":["POST","GET"]}
	 */
	Duration int32 `json:"duration,omitempty"`

	/* {"description":"Measure describing the magnitude of the rate plan's period. If left unspecified: the rate plan will use the same `durationPeriod` magnitude as the Product to which it belongs.","verbs":["POST","GET"]}

	Required: true
	*/
	DurationPeriod string `json:"durationPeriod,omitempty"`

	/* {"default":"None","description":"The action that should be taken, should an invoice for some subscription to this rate plan remain unpaid despite the dunning period's being exceeded.<br><span class=\"label label-default\">CancelSubscription</span> &mdash; Demotes the subscription to the `Failed` state as soon as the dunning period is exceeded.<br><span class=\"label label-default\">None</span> &mdash; The subscription is allowed to continue in the `AwaitingPayment` state indefinitely even if the dunning period is exceeded.For slow payment cycles &mdash; or when manual invoice remediation is common &mdash; <span class=\"label label-default\">None</span> is recommended.<br>In a heavily-automated SaaS environment, automatic cancellation via <span class=\"label label-default\">CancelSubscription</span> is recommended.","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	FailedPaymentBehaviour string `json:"failedPaymentBehaviour,omitempty"`

	/* {"description":"A list linking \"Fixed-Term Definitions\" to the rate plan.","verbs":["POST","PUT","GET"]}
	 */
	FixedTermDefinitions []*MutableBillingEntity `json:"fixedTermDefinitions,omitempty"`

	/* { "description" : "", "verbs":["GET", "PUT"] }
	 */
	ID *string `json:"id,omitempty"`

	/* {"default":"<span class=\"label label-default\">Immediate</span>","description":"The strategy for how invoices for this plan will be issued.<br><span class=\"label label-default\">Immediate</span> &mdash; All generated invoices move immediately to the 'Unpaid' state &mdash; beginning the payment pursuit process.<br><span class=\"label label-default\">Delayed</span> &mdash; All generated invoices begin in the 'Pending' state. An 'Issue Invoice' amendment is scheduled (based on the rate plan's `issueDuration` and `issuePeriod`) that will move the invoice to the 'Unpaid' state (beginning the payment pursuit process) in accordance with the rate plan's issuance schedule.<br><span class=\"label label-default\">Manual</span> &mdash; All generated invoices sit in the 'Pending' state &mdash; they will not be issued to the customer unless explicit action is taken. This gives you an opportunity to review or recalculate the invoice."verbs":["POST","GET"]}
	 */
	InvoiceIssueType *string `json:"invoiceIssueType,omitempty"`

	/* {"description":"Number of issue-length-measures between issuance of invoices for this rate plan.""verbs":["POST","GET"]}
	 */
	IssueDuration int32 `json:"issueDuration,omitempty"`

	/* {"description":"Measure describing the magnitude of the invoice issuance period.","verbs":["POST","GET"]}
	 */
	IssuePeriod *string `json:"issuePeriod,omitempty"`

	/* {"default":"false","description":"Whether the taxes of the rate plan take into account localised taxes.","verbs":["POST","PUT","GET"] }

	Required: true
	*/
	LocalisedTax bool `json:"localisedTax,omitempty"`

	/* { "description" : "Add metadata.", "verbs":["POST"] }
	 */
	Metadata *JaxbDynamicMetadata `json:"metadata,omitempty"`

	/* {"default":"CreditAccount","description":"The action that should be taken, should the pro-rata calculation result in a negative value.<br><span class=\"label label-default\">NoCharge</span> &mdash; Don't return to the customer any money.<br><span class=\"label label-default\">CreditAccount</span> &mdash; Credit the customer's account with the amount.","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	MigrationBehaviour string `json:"migrationBehaviour,omitempty"`

	/* {"description":"A friendly name &mdash; for your benefit &mdash; used to identify this rate plan within some product in BillForward. The name should reflect the fact that this rate plan provides to the customer a price tiering system within which a subscription to its Product can be made. <br>The rate plan's name could describe the nature of its price tiering (e.g. \"Default pricing\", \"Student pricing\").<br>Remember also that rate plans can override the timing prescribed by their product. If your rate plan is defined by its overriding the default timing of its product, then that can be reflected in that rate plan's name. (e.g. \"Student pricing - Annual\").","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	Name string `json:"name,omitempty"`

	/* NotificationObjectGraph notification object graph
	 */
	NotificationObjectGraph *string `json:"notificationObjectGraph,omitempty"`

	PricingComponents []PricingComponent `json:"pricingComponents,omitempty"`

	/* {"default":"WithCoupon","description":"The pro-rata mode for the rate plan. <br><span class=\"label label-default\">None</span> &mdash; The pro-rata cost for upgrades will be ignored.<br><span class=\"label label-default\">WithCoupon</span> &mdash; The pro-rata cost for upgrades will be calculated based on the time remaining for the subscription. Discounts from any attached coupons will be deducted from the pro-rated cost.<br><span class=\"label label-default\">WithoutCoupon</span> &mdash; The pro-rata cost for upgrades will be calculated based on the time remaining for the subscription. Discounts from any attached coupons will not be deducted from the pro-rated cost. ","verbs":[]}

	Required: true
	*/
	ProRataMode string `json:"proRataMode,omitempty"`

	/* {"description":"The product to which this rate plan belongs. A product is essentially a collection of rate plans, and describes the service conferred to a customer upon subscription to any of said product's rate plans. The product serves also as a template from which its rate plans can infer default attributes.","verbs":["POST","GET"]}
	 */
	Product *Product `json:"product,omitempty"`

	/* {"description":"ID of the product to which this rate plan belongs. A product is essentially a collection of rate plans, and describes the service conferred to a customer upon subscription to any of said product's rate plans. The product serves also as a template from which its rate plans can infer default attributes.","verbs":["POST","GET"]}

	Required: true
	*/
	ProductID string `json:"productID,omitempty"`

	/* {"default":"recurring","description":"The frequency of the rate plan &mdash; either recurring or non-recurring. If left unspecified: the rate plan will use the same `productType` frequency as the Product to which it belongs.","verbs":["POST","PUT","GET"]}
	 */
	ProductType *string `json:"productType,omitempty"`

	/* {"description":"A friendly non-unique name used to identify this product-rate-plan","verbs":["POST","PUT","GET"]}
	 */
	PublicName *string `json:"publicName,omitempty"`

	/* RecursionType recursion type
	 */
	RecursionType *string `json:"recursionType,omitempty"`

	/* {"description":"The current status of the rate plan.","verbs":[]}
	 */
	Status *string `json:"status,omitempty"`

	/* {"default":"inclusive","description":"The tax status of the product-rate-plan &mdash; either inclusive or exclusive.<br><span class=\"label label-default\">exclusive</span>pricing indicates that the cost of the Pricing Components do not include tax; when BillForward generates an Invoice, the tax will be calculated with this price as a base. <br>Tax-<span class=\"label label-default\">inclusive</span>pricing indicates that the Pricing components include Tax. BillForward will still calculate tax on each invoice. Tax will be calculated from the sales price.","verbs":["POST","PUT","GET"]}

	Required: true
	*/
	TaxStatus string `json:"taxStatus,omitempty"`

	/* {"description":"A list linking taxation strategies to the rate plan.","verbs":["POST","GET","PUT"]}
	 */
	Taxation []*MutableBillingEntity `json:"taxation,omitempty"`

	/* {"default":0,"description":"Number of trial-length-measures which constitute the rate plan's trial period. If left unspecified: the rate plan will use the same `trial` number as the Product to which it belongs.","verbs":["POST","PUT","GET"]}
	 */
	Trial int32 `json:"trial,omitempty"`

	/* {"default":"none","description":"Measure describing the magnitude of the rate plan's trial period. If left unspecified: the rate plan will use the same `trialPeriod` magnitude as the Product to which it belongs.","verbs":["POST","PUT","GET"]}
	 */
	TrialPeriod *string `json:"trialPeriod,omitempty"`

	/* { "description" : "The UTC DateTime when the object was last updated. ", "verbs":[] }
	 */
	Updated strfmt.DateTime `json:"updated,omitempty"`

	/* {"description":"The UTC DateTime specifying when the rate plan is valid from.","verbs":["GET"]}
	 */
	ValidFrom strfmt.DateTime `json:"validFrom,omitempty"`

	/* {"description":"The UTC DateTime specifying when the product-rate-plan is valid till.","verbs":["GET"]}
	 */
	ValidTill strfmt.DateTime `json:"validTill,omitempty"`
}

// Validate validates this product rate plan
func (m *ProductRatePlan) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAggregatingComponents(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBillingEntity(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCreateZeroValuedInvoices(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCurrency(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDurationPeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFailedPaymentBehaviour(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateFixedTermDefinitions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateInvoiceIssueType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateIssuePeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLocalisedTax(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMigrationBehaviour(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePricingComponents(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProRataMode(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProductID(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProductType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRecursionType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTaxStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTaxation(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTrialPeriod(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ProductRatePlan) validateAggregatingComponents(formats strfmt.Registry) error {

	if swag.IsZero(m.AggregatingComponents) { // not required
		return nil
	}

	for i := 0; i < len(m.AggregatingComponents); i++ {

		if m.AggregatingComponents[i] != nil {

			if err := m.AggregatingComponents[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var productRatePlanBillingEntityEnum []interface{}

func (m *ProductRatePlan) validateBillingEntityEnum(path, location string, value string) error {
	if productRatePlanBillingEntityEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Notification","Organization","OrganizationGateway","Product","User","Subscription","Profile","ProductRatePlan","Client","Invoice","PricingComponentValue","Account","PricingComponentValueChange","PricingComponentTier","PricingComponent","PricingCalculation","CouponDefinition","CouponInstance","CouponModifier","CouponRule","CouponBookDefinition","CouponBook","InvoiceLine","Webhook","SubscriptionCancellation","NotificationSnapshot","InvoicePayment","InvoiceLinePayment","Payment","PaymentMethod","PaymentMethodSubscriptionLink","DunningLine","CybersourceToken","Card","Alias","PaypalSimplePaymentReconciliation","FreePaymentReconciliation","LocustworldPaymentReconciliation","CouponInstanceExistingValue","TaxLine","TaxationStrategy","TaxationLink","Address","AmendmentPriceNTime","Authority","UnitOfMeasure","SearchResult","Amendment","AuditLog","Password","Username","FixedTermDefinition","FixedTerm","Refund","CreditNote","Receipt","AmendmentCompoundConstituent","APIConfiguration","StripeToken","BraintreeToken","BalancedToken","PaypalToken","AuthorizeNetToken","SpreedlyToken","GatewayRevenue","AmendmentDiscardAmendment","CancellationAmendment","CompoundAmendment","CompoundAmendmentConstituent","FixedTermExpiryAmendment","InvoiceNextExecutionAttemptAmendment","PricingComponentValueAmendment","BraintreeMerchantAccount","WebhookSubscription","Migration","CassResult","CassPaymentResult","CassProductRatePlanResult","CassChurnResult","CassUpgradeResult","SubscriptionCharge","CassPaymentPProductResult","ProductPaymentsArgs","StripeACHToken","UsageAmount","UsageSession","Usage","UsagePeriod","Period","OfflinePayment","CreditNotePayment","CardVaultPayment","FreePayment","BraintreePayment","BalancedPayment","CybersourcePayment","PaypalPayment","PaypalSimplePayment","LocustWorldPayment","StripeOnlyPayment","ProductPaymentsResult","StripeACHPayment","AuthorizeNetPayment","CompoundUsageSession","CompoundUsage","UsageRoundingStrategies","BillforwardManagedPaymentsResult","PricingComponentValueMigrationChargeAmendmentMapping","SubscriptionLTVResult","AccountLTVResult","ProductRatePlanPaymentsResult","DebtsResult","AccountPaymentsResult","ComponentChange","QuoteRequest","Quote","CouponCharge","CouponInstanceInvoiceLink","Coupon","CouponDiscount","CouponUniqueCodesRequest","CouponUniqueCodesResponse","GetCouponsResponse","AddCouponCodeRequest","AddCouponCodeResponse","RemoveCouponFromSubscriptionRequest","TokenizationPreAuth","StripeTokenizationPreAuth","BraintreeTokenizationPreAuth","SpreedlyTokenizationPreAuth","SagePayTokenizationPreAuth","PayVisionTokenizationPreAuth","TokenizationPreAuthRequest","AuthCaptureRequest","StripeACHBankAccountVerification","PasswordReset","PricingRequest","AddTaxationStrategyRequest","AddPaymentMethodRequest","APIRequest","SagePayToken","SagePayNotificationRequest","SagePayNotificationResponse","SagePayOutstandingTransaction","SagePayEnabledCardType","TrustCommerceToken","SagePayTransaction","PricingComponentValueResponse","MigrationResponse","TimeResponse","EntityTime","Email","AggregationLink","BFPermission","Role","PermissionLink","PayVisionToken","PayVisionTransaction","KashToken","EmailProvider","DataSynchronizationJob","DataSynchronizationJobError","DataSynchronizationConfiguration","DataSynchronizationAppConfiguration","AggregationChildrenResponse","MetadataKeyValue","Metadata","AggregatingComponent","PricingComponentMigrationValue","InvoiceRecalculationAmendment","IssueInvoiceAmendment","EmailSubscription","RevenueAttribution"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanBillingEntityEnum = append(productRatePlanBillingEntityEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanBillingEntityEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateBillingEntity(formats strfmt.Registry) error {

	if swag.IsZero(m.BillingEntity) { // not required
		return nil
	}

	if err := m.validateBillingEntityEnum("billingEntity", "body", *m.BillingEntity); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateCreateZeroValuedInvoices(formats strfmt.Registry) error {

	if err := validate.Required("createZeroValuedInvoices", "body", bool(m.CreateZeroValuedInvoices)); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateCurrency(formats strfmt.Registry) error {

	if err := validate.Required("currency", "body", string(m.Currency)); err != nil {
		return err
	}

	return nil
}

var productRatePlanDurationPeriodEnum []interface{}

func (m *ProductRatePlan) validateDurationPeriodEnum(path, location string, value string) error {
	if productRatePlanDurationPeriodEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["minutes","days","months","years"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanDurationPeriodEnum = append(productRatePlanDurationPeriodEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanDurationPeriodEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateDurationPeriod(formats strfmt.Registry) error {

	if err := validate.Required("durationPeriod", "body", string(m.DurationPeriod)); err != nil {
		return err
	}

	if err := m.validateDurationPeriodEnum("durationPeriod", "body", m.DurationPeriod); err != nil {
		return err
	}

	return nil
}

var productRatePlanFailedPaymentBehaviourEnum []interface{}

func (m *ProductRatePlan) validateFailedPaymentBehaviourEnum(path, location string, value string) error {
	if productRatePlanFailedPaymentBehaviourEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["CancelSubscription","None"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanFailedPaymentBehaviourEnum = append(productRatePlanFailedPaymentBehaviourEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanFailedPaymentBehaviourEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateFailedPaymentBehaviour(formats strfmt.Registry) error {

	if err := validate.Required("failedPaymentBehaviour", "body", string(m.FailedPaymentBehaviour)); err != nil {
		return err
	}

	if err := m.validateFailedPaymentBehaviourEnum("failedPaymentBehaviour", "body", m.FailedPaymentBehaviour); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateFixedTermDefinitions(formats strfmt.Registry) error {

	if swag.IsZero(m.FixedTermDefinitions) { // not required
		return nil
	}

	for i := 0; i < len(m.FixedTermDefinitions); i++ {

		if m.FixedTermDefinitions[i] != nil {

			if err := m.FixedTermDefinitions[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var productRatePlanInvoiceIssueTypeEnum []interface{}

func (m *ProductRatePlan) validateInvoiceIssueTypeEnum(path, location string, value string) error {
	if productRatePlanInvoiceIssueTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["Immediate","Delayed","Manual"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanInvoiceIssueTypeEnum = append(productRatePlanInvoiceIssueTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanInvoiceIssueTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateInvoiceIssueType(formats strfmt.Registry) error {

	if swag.IsZero(m.InvoiceIssueType) { // not required
		return nil
	}

	if err := m.validateInvoiceIssueTypeEnum("invoiceIssueType", "body", *m.InvoiceIssueType); err != nil {
		return err
	}

	return nil
}

var productRatePlanIssuePeriodEnum []interface{}

func (m *ProductRatePlan) validateIssuePeriodEnum(path, location string, value string) error {
	if productRatePlanIssuePeriodEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["minutes","days","months","years"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanIssuePeriodEnum = append(productRatePlanIssuePeriodEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanIssuePeriodEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateIssuePeriod(formats strfmt.Registry) error {

	if swag.IsZero(m.IssuePeriod) { // not required
		return nil
	}

	if err := m.validateIssuePeriodEnum("issuePeriod", "body", *m.IssuePeriod); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateLocalisedTax(formats strfmt.Registry) error {

	if err := validate.Required("localisedTax", "body", bool(m.LocalisedTax)); err != nil {
		return err
	}

	return nil
}

var productRatePlanMigrationBehaviourEnum []interface{}

func (m *ProductRatePlan) validateMigrationBehaviourEnum(path, location string, value string) error {
	if productRatePlanMigrationBehaviourEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["NoCharge","CreditAccount"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanMigrationBehaviourEnum = append(productRatePlanMigrationBehaviourEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanMigrationBehaviourEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateMigrationBehaviour(formats strfmt.Registry) error {

	if err := validate.Required("migrationBehaviour", "body", string(m.MigrationBehaviour)); err != nil {
		return err
	}

	if err := m.validateMigrationBehaviourEnum("migrationBehaviour", "body", m.MigrationBehaviour); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", string(m.Name)); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validatePricingComponents(formats strfmt.Registry) error {

	if err := validate.Required("pricingComponents", "body", m.PricingComponents); err != nil {
		return err
	}

	for i := 0; i < len(m.PricingComponents); i++ {

		if m.PricingComponents[i] != nil {

			if err := m.PricingComponents[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var productRatePlanProRataModeEnum []interface{}

func (m *ProductRatePlan) validateProRataModeEnum(path, location string, value string) error {
	if productRatePlanProRataModeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["None","WithCoupon","WithoutCoupon","Full"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanProRataModeEnum = append(productRatePlanProRataModeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanProRataModeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateProRataMode(formats strfmt.Registry) error {

	if err := validate.Required("proRataMode", "body", string(m.ProRataMode)); err != nil {
		return err
	}

	if err := m.validateProRataModeEnum("proRataMode", "body", m.ProRataMode); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateProductID(formats strfmt.Registry) error {

	if err := validate.Required("productID", "body", string(m.ProductID)); err != nil {
		return err
	}

	return nil
}

var productRatePlanProductTypeEnum []interface{}

func (m *ProductRatePlan) validateProductTypeEnum(path, location string, value string) error {
	if productRatePlanProductTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["nonrecurring","recurring"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanProductTypeEnum = append(productRatePlanProductTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanProductTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateProductType(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductType) { // not required
		return nil
	}

	if err := m.validateProductTypeEnum("productType", "body", *m.ProductType); err != nil {
		return err
	}

	return nil
}

var productRatePlanRecursionTypeEnum []interface{}

func (m *ProductRatePlan) validateRecursionTypeEnum(path, location string, value string) error {
	if productRatePlanRecursionTypeEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["nonrecurring","recurring"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanRecursionTypeEnum = append(productRatePlanRecursionTypeEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanRecursionTypeEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateRecursionType(formats strfmt.Registry) error {

	if swag.IsZero(m.RecursionType) { // not required
		return nil
	}

	if err := m.validateRecursionTypeEnum("recursionType", "body", *m.RecursionType); err != nil {
		return err
	}

	return nil
}

var productRatePlanTaxStatusEnum []interface{}

func (m *ProductRatePlan) validateTaxStatusEnum(path, location string, value string) error {
	if productRatePlanTaxStatusEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["inclusive","exclusive"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanTaxStatusEnum = append(productRatePlanTaxStatusEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanTaxStatusEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateTaxStatus(formats strfmt.Registry) error {

	if err := validate.Required("taxStatus", "body", string(m.TaxStatus)); err != nil {
		return err
	}

	if err := m.validateTaxStatusEnum("taxStatus", "body", m.TaxStatus); err != nil {
		return err
	}

	return nil
}

func (m *ProductRatePlan) validateTaxation(formats strfmt.Registry) error {

	if swag.IsZero(m.Taxation) { // not required
		return nil
	}

	for i := 0; i < len(m.Taxation); i++ {

		if m.Taxation[i] != nil {

			if err := m.Taxation[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

var productRatePlanTrialPeriodEnum []interface{}

func (m *ProductRatePlan) validateTrialPeriodEnum(path, location string, value string) error {
	if productRatePlanTrialPeriodEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["none","minutes","days","months"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			productRatePlanTrialPeriodEnum = append(productRatePlanTrialPeriodEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, productRatePlanTrialPeriodEnum); err != nil {
		return err
	}
	return nil
}

func (m *ProductRatePlan) validateTrialPeriod(formats strfmt.Registry) error {

	if swag.IsZero(m.TrialPeriod) { // not required
		return nil
	}

	if err := m.validateTrialPeriodEnum("trialPeriod", "body", *m.TrialPeriod); err != nil {
		return err
	}

	return nil
}

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *ProductRatePlan) UnmarshalJSON(raw []byte) error {
	var data struct {
		AggregatingComponents []*AggregatingComponent `json:"aggregatingComponents,omitempty"`

		BillingEntity *string `json:"billingEntity,omitempty"`

		ChangedBy *string `json:"changedBy,omitempty"`

		CreateZeroValuedInvoices bool `json:"createZeroValuedInvoices,omitempty"`

		Created strfmt.DateTime `json:"created,omitempty"`

		Crmid *string `json:"crmid,omitempty"`

		Currency string `json:"currency,omitempty"`

		DisplayName *string `json:"displayName,omitempty"`

		Duration int32 `json:"duration,omitempty"`

		DurationPeriod string `json:"durationPeriod,omitempty"`

		FailedPaymentBehaviour string `json:"failedPaymentBehaviour,omitempty"`

		FixedTermDefinitions []*MutableBillingEntity `json:"fixedTermDefinitions,omitempty"`

		ID *string `json:"id,omitempty"`

		InvoiceIssueType *string `json:"invoiceIssueType,omitempty"`

		IssueDuration int32 `json:"issueDuration,omitempty"`

		IssuePeriod *string `json:"issuePeriod,omitempty"`

		LocalisedTax bool `json:"localisedTax,omitempty"`

		Metadata *JaxbDynamicMetadata `json:"metadata,omitempty"`

		MigrationBehaviour string `json:"migrationBehaviour,omitempty"`

		Name string `json:"name,omitempty"`

		NotificationObjectGraph *string `json:"notificationObjectGraph,omitempty"`

		ProRataMode string `json:"proRataMode,omitempty"`

		Product *Product `json:"product,omitempty"`

		ProductID string `json:"productID,omitempty"`

		ProductType *string `json:"productType,omitempty"`

		PublicName *string `json:"publicName,omitempty"`

		RecursionType *string `json:"recursionType,omitempty"`

		Status *string `json:"status,omitempty"`

		TaxStatus string `json:"taxStatus,omitempty"`

		Taxation []*MutableBillingEntity `json:"taxation,omitempty"`

		Trial int32 `json:"trial,omitempty"`

		TrialPeriod *string `json:"trialPeriod,omitempty"`

		Updated strfmt.DateTime `json:"updated,omitempty"`

		ValidFrom strfmt.DateTime `json:"validFrom,omitempty"`

		ValidTill strfmt.DateTime `json:"validTill,omitempty"`
	}

	if err := json.Unmarshal(raw, &data); err != nil {
		return err
	}

	var pricingComponents []PricingComponent
	untypedObj := make(map[string]interface{})
	if err := json.Unmarshal(raw, &untypedObj); err != nil {
		return err
	}
	if untypedPricingComponents, ok := untypedObj["pricingComponents"]; ok {
		if slcPricingComponents, ok := untypedPricingComponents.([]interface{}); ok {
			for _, slcEl := range slcPricingComponents {
				slcJSON, _ := json.Marshal(slcEl)
				slcObj, err := UnmarshalPricingComponent(bytes.NewBuffer(slcJSON), httpkit.JSONConsumer())
				if err != nil {
					return err
				}
				pricingComponents = append(pricingComponents, slcObj)
			}
		}
	}

	var result ProductRatePlan
	result.AggregatingComponents = data.AggregatingComponents
	result.BillingEntity = data.BillingEntity
	result.ChangedBy = data.ChangedBy
	result.CreateZeroValuedInvoices = data.CreateZeroValuedInvoices
	result.Created = data.Created
	result.Crmid = data.Crmid
	result.Currency = data.Currency
	result.DisplayName = data.DisplayName
	result.Duration = data.Duration
	result.DurationPeriod = data.DurationPeriod
	result.FailedPaymentBehaviour = data.FailedPaymentBehaviour
	result.FixedTermDefinitions = data.FixedTermDefinitions
	result.ID = data.ID
	result.InvoiceIssueType = data.InvoiceIssueType
	result.IssueDuration = data.IssueDuration
	result.IssuePeriod = data.IssuePeriod
	result.LocalisedTax = data.LocalisedTax
	result.Metadata = data.Metadata
	result.MigrationBehaviour = data.MigrationBehaviour
	result.Name = data.Name
	result.NotificationObjectGraph = data.NotificationObjectGraph
	result.PricingComponents = pricingComponents
	result.ProRataMode = data.ProRataMode
	result.Product = data.Product
	result.ProductID = data.ProductID
	result.ProductType = data.ProductType
	result.PublicName = data.PublicName
	result.RecursionType = data.RecursionType
	result.Status = data.Status
	result.TaxStatus = data.TaxStatus
	result.Taxation = data.Taxation
	result.Trial = data.Trial
	result.TrialPeriod = data.TrialPeriod
	result.Updated = data.Updated
	result.ValidFrom = data.ValidFrom
	result.ValidTill = data.ValidTill
	*m = result
	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m ProductRatePlan) MarshalJSON() ([]byte, error) {
	var b1, b2 []byte
	var err error
	b1, err = json.Marshal(struct {
		AggregatingComponents []*AggregatingComponent `json:"aggregatingComponents,omitempty"`

		BillingEntity *string `json:"billingEntity,omitempty"`

		ChangedBy *string `json:"changedBy,omitempty"`

		CreateZeroValuedInvoices bool `json:"createZeroValuedInvoices,omitempty"`

		Created strfmt.DateTime `json:"created,omitempty"`

		Crmid *string `json:"crmid,omitempty"`

		Currency string `json:"currency,omitempty"`

		DisplayName *string `json:"displayName,omitempty"`

		Duration int32 `json:"duration,omitempty"`

		DurationPeriod string `json:"durationPeriod,omitempty"`

		FailedPaymentBehaviour string `json:"failedPaymentBehaviour,omitempty"`

		FixedTermDefinitions []*MutableBillingEntity `json:"fixedTermDefinitions,omitempty"`

		ID *string `json:"id,omitempty"`

		InvoiceIssueType *string `json:"invoiceIssueType,omitempty"`

		IssueDuration int32 `json:"issueDuration,omitempty"`

		IssuePeriod *string `json:"issuePeriod,omitempty"`

		LocalisedTax bool `json:"localisedTax,omitempty"`

		Metadata *JaxbDynamicMetadata `json:"metadata,omitempty"`

		MigrationBehaviour string `json:"migrationBehaviour,omitempty"`

		Name string `json:"name,omitempty"`

		NotificationObjectGraph *string `json:"notificationObjectGraph,omitempty"`

		ProRataMode string `json:"proRataMode,omitempty"`

		Product *Product `json:"product,omitempty"`

		ProductID string `json:"productID,omitempty"`

		ProductType *string `json:"productType,omitempty"`

		PublicName *string `json:"publicName,omitempty"`

		RecursionType *string `json:"recursionType,omitempty"`

		Status *string `json:"status,omitempty"`

		TaxStatus string `json:"taxStatus,omitempty"`

		Taxation []*MutableBillingEntity `json:"taxation,omitempty"`

		Trial int32 `json:"trial,omitempty"`

		TrialPeriod *string `json:"trialPeriod,omitempty"`

		Updated strfmt.DateTime `json:"updated,omitempty"`

		ValidFrom strfmt.DateTime `json:"validFrom,omitempty"`

		ValidTill strfmt.DateTime `json:"validTill,omitempty"`
	}{
		AggregatingComponents:    m.AggregatingComponents,
		BillingEntity:            m.BillingEntity,
		ChangedBy:                m.ChangedBy,
		CreateZeroValuedInvoices: m.CreateZeroValuedInvoices,
		Created:                  m.Created,
		Crmid:                    m.Crmid,
		Currency:                 m.Currency,
		DisplayName:              m.DisplayName,
		Duration:                 m.Duration,
		DurationPeriod:           m.DurationPeriod,
		FailedPaymentBehaviour:   m.FailedPaymentBehaviour,
		FixedTermDefinitions:     m.FixedTermDefinitions,
		ID:                       m.ID,
		InvoiceIssueType:         m.InvoiceIssueType,
		IssueDuration:            m.IssueDuration,
		IssuePeriod:              m.IssuePeriod,
		LocalisedTax:             m.LocalisedTax,
		Metadata:                 m.Metadata,
		MigrationBehaviour:       m.MigrationBehaviour,
		Name:                     m.Name,
		NotificationObjectGraph: m.NotificationObjectGraph,
		ProRataMode:             m.ProRataMode,
		Product:                 m.Product,
		ProductID:               m.ProductID,
		ProductType:             m.ProductType,
		PublicName:              m.PublicName,
		RecursionType:           m.RecursionType,
		Status:                  m.Status,
		TaxStatus:               m.TaxStatus,
		Taxation:                m.Taxation,
		Trial:                   m.Trial,
		TrialPeriod:             m.TrialPeriod,
		Updated:                 m.Updated,
		ValidFrom:               m.ValidFrom,
		ValidTill:               m.ValidTill,
	})
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		PricingComponents []PricingComponent `json:"pricingComponents,omitempty"`
	}{
		PricingComponents: m.PricingComponents,
	})
	if err != nil {
		return nil, err
	}
	return swag.ConcatJSON(b1, b2), nil
}
