package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"io"
	"io/ioutil"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit"
	"github.com/go-swagger/go-swagger/httpkit/validate"
	"github.com/go-swagger/go-swagger/strfmt"
)

/*PricingComponent pricing component

swagger:discriminator PricingComponent chargeModel
*/
type PricingComponent interface {
	httpkit.Validatable

	/* BillingEntity billing entity
	 */
	BillingEntity() string

	/* { "description" : "ID of the user who last updated the entity.", "verbs":[] }
	 */
	ChangedBy() string

	/* { "description" : "The charge model of the pricing-component.", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	ChargeModel() string

	/* { "description" : "The charge type of the pricing-component.", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	ChargeType() string

	/* ComponentValue component value
	 */
	ComponentValue() int32

	/* { "description" : "ID of the pricing-component. This ID does not change with new versions of the pricing component.", "verbs":["POST","PUT","GET"] } When associating a pricing component with a product rate plan, this ID should be used.

	Required: true
	*/
	ConsistentID() string

	/* Cost cost
	 */
	Cost() float64

	/* { "description" : "The UTC DateTime when the object was created.", "verbs":[] }
	 */
	Created() strfmt.DateTime

	/* Crmid crmid
	 */
	Crmid() string

	/* { "description" : "The default quantity of the pricing-component. If no value is supplied on a subscription this value will be used. This is useful for setting an expected purchase level of for introducing new pricing components to existing subscriptions and not having to back-fill values", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	DefaultQuantity() int32

	/* { "description" : "", "verbs":["POST","PUT","GET"] }
	 */
	Description() string

	/* {"default":"<span class=\"label label-default\">delayed</span>","description":"Default behaviour when a value is downgraded using this pricing component, this behaviour can be overridden when changing the value.<br><span class=\"label label-default\">immediate</span> &mdash; Downgrade will apply at the time the request is made.<br><span class=\"label label-default\">delayed</span> &mdash; Downgrade will apply at the end of the current billing cycle.","verbs":["POST","GET"]}
	 */
	DowngradeMode() string

	/* { "description" : "", "default" : "", "verbs":["POST","GET"] }

	Required: true
	*/
	DummyField() string

	/* { "description" : "Version ID of the pricing-component. Unique ID for each version of a pricing-component.", "verbs":["POST","PUT","GET"] }
	 */
	ID() string

	/* { "default" : "Aggregated",  "description" : "For <span class=\"label label-default\">setup</span> pricing components <span class=\"label label-default\">Immediate</span> invoicing will result in an invoice being issued on subscription being set to the AwaitingPayment state, irrespective of the subscription start date. <span class=\"label label-default\">Aggregated</span> invoicing will add a charge to the first invoice of the subscription.", "verbs":["POST","PUT","GET"] }
	 */
	InvoicingType() string

	/* { "description" : "The maximum quantity of the pricing-component.", "verbs":[] }
	 */
	MaxQuantity() int32

	/* { "default" : "0", "description" : "The minimum quantity of the pricing-component.", "verbs":[] }
	 */
	MinQuantity() int32

	/* { "description" : "", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	Name() string

	/* NotificationObjectGraph notification object graph
	 */
	NotificationObjectGraph() string

	/* { "description" : "", "verbs":[] }

	Required: true
	*/
	OrganizationID() string

	/* PriceExplanation price explanation
	 */
	PriceExplanation() []string

	/* PriceExplanationString price explanation string
	 */
	PriceExplanationString() string

	/* { "description" : "The product-rate-plan associated with the pricing-component.", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	ProductRatePlan() *ProductRatePlan

	/* { "description" : "", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	ProductRatePlanID() string

	/* {  "default" : "[]", "description" : "The pricing-component-tiers associated with the pricing-component.", "verbs":["POST","PUT","GET"] }
	 */
	Tiers() []*PricingComponentTier

	/* { "description" : "", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	UnitOfMeasureID() string

	/* { "description" : "The UTC DateTime when the object was last updated. ", "verbs":[] }
	 */
	Updated() strfmt.DateTime

	/* {"default":"<span class=\"label label-default\">immediate</span>","description":"Default behaviour when a value is upgraded using this pricing component, this behaviour can be overridden when changing the value.<br><span class=\"label label-default\">immediate</span> &mdash; Upgrade will apply at the time the request is made.<br><span class=\"label label-default\">delayed</span> &mdash; Upgrade will apply at the end of the current billing cycle.","verbs":["POST","GET"]}
	 */
	UpgradeMode() string

	/* { "default" : "current time", "description" : "The DateTime specifying when the pricing-component is valid from.", "verbs":["POST","PUT","GET"] }

	Required: true
	*/
	ValidFrom() strfmt.DateTime

	/* {  "default" : "null", "description" : "The UTC DateTime specifying when the pricing-component is valid till.", "verbs":["POST","PUT","GET"] }
	 */
	ValidTill() strfmt.DateTime
}

func UnmarshalPricingComponent(reader io.Reader, consumer httpkit.Consumer) (PricingComponent, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	buf := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the chargeModel property.
	var getType struct {
		ChargeModel string `json:"chargeModel"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("chargeModel", "body", getType.ChargeModel); err != nil {
		return nil, err
	}

	// The value of chargeModel is used to determine which type to create and unmarshal the data into
	switch getType.ChargeModel {
	case "FlatPricingComponent":
		var result FlatPricingComponent
		if err := consumer.Consume(buf, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "TieredPricingComponent":
		var result TieredPricingComponent
		if err := consumer.Consume(buf, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "TieredVolumePricingComponent":
		var result TieredVolumePricingComponent
		if err := consumer.Consume(buf, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid chargeModel value: %q", getType.ChargeModel)

}
